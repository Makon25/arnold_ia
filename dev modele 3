import tensorflow as tf
import numpy as np
import cv2
import os

# === Chemins mis √† jour ===
model_ch_path = "/Users/macbookair/Desktop/Projet_IA/MODELE_IA2/converted_CH_V2_tflite (1)/model_unquant.tflite"
labels_ch_path = "/Users/macbookair/Desktop/Projet_IA/MODELE_IA2/converted_CH_V2_tflite (1)/labels.txt"

model_cl_path = "/Users/macbookair/Desktop/Projet_IA/MODELE_IA2/converted_CL_V2_tflite/model_unquant.tflite"
labels_cl_path = "/Users/macbookair/Desktop/Projet_IA/MODELE_IA2/converted_CL_V2_tflite/labels.txt"

# === Chargement des mod√®les TFLite
interpreter_haut = tf.lite.Interpreter(model_path=model_ch_path)
interpreter_haut.allocate_tensors()

interpreter_lat = tf.lite.Interpreter(model_path=model_cl_path)
interpreter_lat.allocate_tensors()

# === Chargement des labels
def charger_labels(path, label_type):
    labels = []
    with open(path, "r") as f:
        lines = f.readlines()
        for line in lines:
            parts = line.strip().split(" ", 1)
            print(f"{label_type} Label brut : {parts}")
            if len(parts) == 2:
                labels.append(parts[1])
            else:
                print(f"‚ö†Ô∏è Erreur parsing dans {label_type} : '{line.strip()}'")
    return labels

labels_haut = charger_labels(labels_ch_path, "CH")
labels_lat = charger_labels(labels_cl_path, "CL")

# === Mappage corrig√© pour les labels en MAJUSCULES
MAPPING = {
    "CH_BON": "bonne",
    "CH_REMANU": "remanufacturable",
    "CH_RECY": "recyclable",

    "CL_BON": "bonne",
    "CL_REPA": "r√©parable",
    "CL_RECY": "recyclable"
}

# === Gravit√© des d√©cisions
gravit√© = {
    "Le corps est en bon √©tat": 0,
    "Le corps doit √™tre r√©par√©": 1,
    "Le corps n√©cessite un remanufacturing": 2,
    "Le corps est √† recycler": 3,
    "Le corps est √† v√©rifier manuellement": 4
}

# === Grille d'√©tat unitaire
def determiner_etat_unitaire(haut, lat):
    grille = {
        ("bonne", "bonne"): "Le corps est en bon √©tat",
        ("bonne", "r√©parable"): "Le corps doit √™tre r√©par√©",
        ("bonne", "remanufacturable"): "Le corps n√©cessite un remanufacturing",
        ("bonne", "recyclable"): "Le corps est √† recycler",

        ("r√©parable", "bonne"): "Le corps doit √™tre r√©par√©",
        ("r√©parable", "r√©parable"): "Le corps doit √™tre r√©par√©",
        ("r√©parable", "remanufacturable"): "Le corps n√©cessite un remanufacturing",
        ("r√©parable", "recyclable"): "Le corps est √† recycler",

        ("remanufacturable", "bonne"): "Le corps n√©cessite un remanufacturing",
        ("remanufacturable", "r√©parable"): "Le corps n√©cessite un remanufacturing",
        ("remanufacturable", "remanufacturable"): "Le corps n√©cessite un remanufacturing",
        ("remanufacturable", "recyclable"): "Le corps est √† recycler",

        ("recyclable", "bonne"): "Le corps est √† recycler",
        ("recyclable", "r√©parable"): "Le corps est √† recycler",
        ("recyclable", "remanufacturable"): "Le corps est √† recycler",
        ("recyclable", "recyclable"): "Le corps est √† recycler",
    }
    return grille.get((haut, lat), "Le corps est √† v√©rifier manuellement")

# === Fusion globale
def determiner_etat_global(haut, list_lat):
    decisions = [determiner_etat_unitaire(haut, lat) for lat in list_lat]
    decisions.sort(key=lambda x: gravit√©.get(x, 4), reverse=True)
    return decisions[0], decisions

# === Pr√©diction image par image
def predict_image(image, interpreter, labels):
    input_details = interpreter.get_input_details()
    output_details = interpreter.get_output_details()

    input_shape = input_details[0]['shape']
    input_dtype = input_details[0]['dtype']

    img = cv2.resize(image, (input_shape[2], input_shape[1]))

    if input_dtype == np.uint8:
        img = np.expand_dims(img.astype(np.uint8), axis=0)
    else:
        img = np.expand_dims(img.astype(np.float32) / 255.0, axis=0)

    interpreter.set_tensor(input_details[0]['index'], img)
    interpreter.invoke()
    output_data = interpreter.get_tensor(output_details[0]['index'])

    print("üß† Scores bruts :", output_data[0])

    predicted_index = np.argmax(output_data[0])
    raw_label = labels[predicted_index]
    print(f"üîç Label brut : '{raw_label}'")

    mapped_label = MAPPING.get(raw_label)
    if mapped_label is None:
        print(f"‚ö†Ô∏è Label non mapp√© : '{raw_label}'")
        print("Cl√©s du MAPPING :", list(MAPPING.keys()))
        raise ValueError(f"Label non reconnu : {raw_label}")

    confidence = output_data[0][predicted_index]
    return mapped_label, confidence

# === Lecture et analyse d'une pi√®ce
def analyser_piece_par_dossier(ch_dir, cl1_dir, cl2_dir, cl3_dir):
    def load_first_image(path):
        for file in os.listdir(path):
            if file.lower().endswith((".jpg", ".jpeg", ".png")):
                full_path = os.path.join(path, file)
                print(f"üìÇ Chargement image : {full_path}")
                return cv2.imread(full_path)
        raise FileNotFoundError(f"Aucune image trouv√©e dans : {path}")

    img_haut = load_first_image(ch_dir)
    img_lat1 = load_first_image(cl1_dir)
    img_lat2 = load_first_image(cl2_dir)
    img_lat3 = load_first_image(cl3_dir)

    res_haut, conf_haut = predict_image(img_haut, interpreter_haut, labels_haut)
    res_lat1, conf_lat1 = predict_image(img_lat1, interpreter_lat, labels_lat)
    res_lat2, conf_lat2 = predict_image(img_lat2, interpreter_lat, labels_lat)
    res_lat3, conf_lat3 = predict_image(img_lat3, interpreter_lat, labels_lat)

    lat_states = [res_lat1, res_lat2, res_lat3]
    etat_final, decisions = determiner_etat_global(res_haut, lat_states)

    print("\n=== Analyse compl√®te ===")
    print(f"Corps haut : {res_haut} ({conf_haut:.2%})")
    print(f"Lat√©rale 1 : {res_lat1} ({conf_lat1:.2%}) ‚Üí {determiner_etat_unitaire(res_haut, res_lat1)}")
    print(f"Lat√©rale 2 : {res_lat2} ({conf_lat2:.2%}) ‚Üí {determiner_etat_unitaire(res_haut, res_lat2)}")
    print(f"Lat√©rale 3 : {res_lat3} ({conf_lat3:.2%}) ‚Üí {determiner_etat_unitaire(res_haut, res_lat3)}")
    print(f"\nüß† D√©cision finale : {etat_final}")

# === Lancement de l‚Äôanalyse (√† adapter selon la pi√®ce test√©e)
analyser_piece_par_dossier(
    "/Users/macbookair/Desktop/Projet_IA/dossier_imag_test/Piece1/CH",
    "/Users/macbookair/Desktop/Projet_IA/dossier_imag_test/Piece1/CL1",
    "/Users/macbookair/Desktop/Projet_IA/dossier_imag_test/Piece1/CL2",
    "/Users/macbookair/Desktop/Projet_IA/dossier_imag_test/Piece1/CL3"
)
